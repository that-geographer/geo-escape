<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ü–æ–±–µ–≥ –≥–µ–æ–≥—Ä–∞—Ñ–∞: –ù–æ–≤–æ–≥–æ–¥–Ω–∏–π –ø–µ—Ä–µ–ø–æ–ª–æ—Ö</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a2a3a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background-color: #f8f9fa;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            max-width: 100%;
            max-height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: #2c3e50;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.7);
            z-index: 5;
        }
        .menu-overlay {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            padding: 2rem;
            border-radius: 1.5rem;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            z-index: 100;
            max-width: 90%;
            width: 450px;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        .btn {
            background: #c0392b;
            color: white;
            padding: 10px 24px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 0 #962d22;
            width: 100%;
        }
        .btn:hover { background: #e74c3c; transform: translateY(-2px); }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        .btn-secondary { background: #34495e; box-shadow: 0 4px 0 #2c3e50; }
        .btn-secondary:hover { background: #45627d; }

        .input-field {
            padding: 12px;
            border: 2px solid #dcdde1;
            border-radius: 10px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
            width: 100%;
        }
        .input-field:focus { border-color: #c0392b; }

        .hidden { display: none !important; }
        
        .progress-bar-bg {
            width: 200px;
            height: 14px;
            background: #dcdde1;
            border-radius: 7px;
            margin-top: 5px;
            overflow: hidden;
            border: 2px solid #2c3e50;
        }
        #progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #c0392b, #e74c3c);
            transition: width 0.3s ease-out;
        }
        #level-up-announcement {
            position: absolute;
            font-size: 3rem;
            font-weight: 900;
            color: #27ae60;
            pointer-events: none;
            opacity: 0;
            transition: all 0.5s;
            z-index: 20;
            text-shadow: 2px 2px 0px white;
            text-align: center;
        }

        .results-list {
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .result-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #active-effects {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }
        .effect-tag {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        input[type=range] {
            height: 25px;
            -webkit-appearance: none;
            margin: 10px 0;
            width: 100%;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            animate: 0.2s;
            background: #dcdde1;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #c0392b;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -6px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="level-up-announcement">–ù–û–í–´–ô –ì–û–î –ë–õ–ò–ó–ö–û!</div>

    <div id="active-effects"></div>
    
    <div id="ui-overlay" class="hidden">
        <div>
            <div class="text-xl font-bold" id="level-title">–£—Ä–æ–≤–µ–Ω—å: <span id="level-val">1</span></div>
            <div class="text-sm font-semibold" id="score-container">–¢–µ—Ç—Ä–∞–¥–∏: <span id="score">0</span> / 20</div>
            <div class="progress-bar-bg"><div id="progress-fill"></div></div>
            <div class="mt-2 font-bold text-red-700">–û—á–∫–∏: <span id="total-points">0</span></div>
            <div class="text-xs text-gray-600">–ò–≥—Ä–æ–∫: <span id="ui-nickname">–ì–µ–æ–≥—Ä–∞—Ñ</span></div>
        </div>
        <div class="text-right">
            <div id="ability-status" class="font-bold text-blue-600">–ì–õ–û–ë–£–°: –ì–û–¢–û–í</div>
            <div id="ult-status" class="font-bold text-purple-600">–£–õ–¨–¢–ê [E]: –ì–û–¢–û–í–ê</div>
        </div>
    </div>

    <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
    <div id="main-menu" class="menu-overlay">
        <h1 class="text-3xl font-extrabold text-red-700">üéÑ –ü–æ–±–µ–≥ –≥–µ–æ–≥—Ä–∞—Ñ–∞</h1>
        <p class="text-sm text-gray-600 mb-2">–ù–µ–¥–µ–ª—è –¥–æ –ù–æ–≤–æ–≥–æ –≥–æ–¥–∞. –¢–æ–ª–ø—ã —É—á–µ–Ω–∏–∫–æ–≤ –Ω–µ—Å—É—Ç —Å–≤–æ–∏ —Ç–µ—Ç—Ä–∞–¥–∏, —á—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å –¥–≤–æ–π–∫–∏. –ù–µ –ø–æ–ø–∞–¥–∏—Ç–µ—Å—å!</p>
        
        <input type="text" id="nickname-input" class="input-field" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫..." maxlength="12">
        
        <button id="start-btn" class="btn">–ù–∞—á–∞—Ç—å –∑–∞–±–µ–≥</button>
        <button id="controls-btn" class="btn btn-secondary">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
        <button id="settings-btn" class="btn btn-secondary">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
        <button id="results-btn" class="btn btn-secondary">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</button>
    </div>

    <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
    <div id="settings-menu" class="menu-overlay hidden">
        <h2 class="text-2xl font-bold text-gray-800">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–≤—É–∫–∞</h2>
        
        <div class="w-full text-left bg-gray-100 p-4 rounded-xl space-y-4">
            <div class="flex items-center justify-between">
                <span class="font-bold text-gray-700">–ó–≤—É–∫ –∏ –ú—É–∑—ã–∫–∞</span>
                <input type="checkbox" id="sound-toggle" checked class="w-6 h-6 accent-red-600 cursor-pointer">
            </div>

            <div>
                <div class="flex justify-between mb-1">
                    <span class="text-sm font-bold text-gray-600">–ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (SFX)</span>
                    <span id="sfx-val" class="text-sm text-gray-500">100%</span>
                </div>
                <input type="range" id="sfx-volume" min="0" max="1" step="0.1" value="1.0">
            </div>

            <div>
                <div class="flex justify-between mb-1">
                    <span class="text-sm font-bold text-gray-600">–ú—É–∑—ã–∫–∞ (BGM)</span>
                    <span id="music-val" class="text-sm text-gray-500">10%</span>
                </div>
                <input type="range" id="music-volume" min="0" max="1" step="0.1" value="0.1">
            </div>
        </div>

        <button id="back-to-main-from-settings" class="btn">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
    <div id="controls-menu" class="menu-overlay hidden">
        <h2 class="text-2xl font-bold text-gray-800">–ö–ª–∞–≤–∏—à–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h2>
        <div class="text-left space-y-2 my-2 text-gray-700 text-sm">
            <p><b>–°—Ç—Ä–µ–ª–∫–∏:</b> –ü–µ—Ä–µ–¥–≤–∏–∂–µ–Ω–∏–µ —É—á–∏—Ç–µ–ª—è</p>
            <p><b>–ö–ª–∞–≤–∏—à–∏ W,A,S,D:</b> –í—ã–±–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±—Ä–æ—Å–∫–∞</p>
            <p><b>–ü—Ä–æ–±–µ–ª:</b> –ë—Ä–æ—Å–∏—Ç—å –≥–ª–æ–±—É—Å</p>
            <p><b>–ö–ª–∞–≤–∏—à–∞ E:</b> –£–ª—å—Ç–∞ (–≥–ª–æ–±—É—Å—ã –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã)</p>
            <hr>
            <p>üéÅ <b>–ë–æ–Ω—É—Å—ã:</b> –í—ã–ø–∞–¥–∞—é—Ç –∏–∑ —É—á–µ–Ω–∏–∫–æ–≤ (–º–∞–∫—Å. 3 –∑–∞ —É—Ä–æ–≤–µ–Ω—å)</p>
        </div>
        <button id="back-to-main-from-ctrl" class="btn">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã -->
    <div id="results-menu" class="menu-overlay hidden">
        <h2 class="text-2xl font-bold text-gray-800">–õ—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div id="results-container" class="results-list"></div>
        <button id="back-to-main-from-res" class="btn mt-4">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã -->
    <div id="game-over-menu" class="menu-overlay hidden">
        <h2 class="text-3xl font-bold text-red-600">–í–∞—Å –∑–∞–≤–∞–ª–∏–ª–∏ —Ç–µ—Ç—Ä–∞–¥—è–º–∏!</h2>
        <div class="my-4 text-xl">
            –†–µ–∑—É–ª—å—Ç–∞—Ç <span id="player-name-final"></span>: <span id="final-points" class="font-bold">0</span>
        </div>
        <button id="retry-btn" class="btn">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        <button id="to-menu-btn" class="btn btn-secondary">–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const uiOverlay = document.getElementById('ui-overlay');
    const mainMenu = document.getElementById('main-menu');
    const controlsMenu = document.getElementById('controls-menu');
    const settingsMenu = document.getElementById('settings-menu');
    const resultsMenu = document.getElementById('results-menu');
    const gameOverMenu = document.getElementById('game-over-menu');
    const nicknameInput = document.getElementById('nickname-input');
    const effectsContainer = document.getElementById('active-effects');
    
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level-val');
    const pointsElement = document.getElementById('total-points');
    const progressFill = document.getElementById('progress-fill');
    const levelAnnounce = document.getElementById('level-up-announcement');
    const scoreContainer = document.getElementById('score-container');
    const levelTitle = document.getElementById('level-title');

    // === AUDIO SYSTEM ===
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const soundBuffers = {};
    let bgmAudio = new Audio('https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/Music.mp3');
    bgmAudio.loop = true;

    const audioSettings = {
        enabled: true,
        sfxVolume: 1.0,
        musicVolume: 0.1
    };

    const soundUrls = {
        globeHit: [
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/01Globeshot1.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/01Globeshot2.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/01Globeshot3.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/01Globeshot4.mp3'
        ],
        globeThrow: [
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/02Globekick1.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/02Globekick2.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/02Globekick3.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/02Globekick4.mp3'
        ],
        studentHit: [
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/03Studenthit1.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/03Studenthit2.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/03Studenthit3.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/03Studenthit4.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/03Studenthit5.mp3'
        ],
        specialShot: [
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/04Copybookkick.mp3'
        ],
        bossShot: [
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/05Spetialstudentkick1.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/05Spetialstudentkick2.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/05Spetialstudentkick3.mp3',
            'https://raw.githubusercontent.com/that-geographer/geo-escape/main/assets/05Spetialstudentkick4.mp3'
        ]
    };

    // Preload sounds
    async function loadSound(category, url) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            if (!soundBuffers[category]) soundBuffers[category] = [];
            soundBuffers[category].push(audioBuffer);
            console.log(`Loaded sound: ${url}`);
        } catch (e) {
            console.error('Failed to load sound:', url, e);
        }
    }

    // Initialize loading
    Object.keys(soundUrls).forEach(category => {
        soundUrls[category].forEach(url => loadSound(category, url));
    });

    function playSound(category) {
        if (!audioSettings.enabled || !soundBuffers[category] || soundBuffers[category].length === 0) return;
        
        // Randomly pick a buffer from the category
        const buffers = soundBuffers[category];
        const buffer = buffers[Math.floor(Math.random() * buffers.length)];

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = audioSettings.sfxVolume;
        
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);
    }

    function updateMusicVolume() {
        if (audioSettings.enabled) {
            bgmAudio.volume = audioSettings.musicVolume;
            if (gameActive && bgmAudio.paused) bgmAudio.play().catch(e => console.log(e));
        } else {
            bgmAudio.pause();
        }
    }

    // === SETTINGS EVENTS ===
    document.getElementById('sound-toggle').addEventListener('change', (e) => {
        audioSettings.enabled = e.target.checked;
        updateMusicVolume();
    });

    document.getElementById('sfx-volume').addEventListener('input', (e) => {
        audioSettings.sfxVolume = parseFloat(e.target.value);
        document.getElementById('sfx-val').innerText = Math.round(audioSettings.sfxVolume * 100) + '%';
    });

    document.getElementById('music-volume').addEventListener('input', (e) => {
        audioSettings.musicVolume = parseFloat(e.target.value);
        document.getElementById('music-val').innerText = Math.round(audioSettings.musicVolume * 100) + '%';
        updateMusicVolume();
    });

    // === GAME ASSETS ===
    const assets = {
        player: new Image(),
        desk: new Image(),
        chair: new Image(),
        studentNormal: new Image(),
        studentSpecial: new Image(),
        globe: new Image(),
        itemRefresher: new Image(),
        itemSlowmo: new Image(),
        itemInvul: new Image()
    };
    
    // New Image URLs
    assets.player.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Geographer.png';
    assets.desk.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Desk.png';
    assets.chair.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Chair.png';
    assets.studentNormal.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Student1.png';
    assets.studentSpecial.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Student2.png';
    assets.globe.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Globe.png';
    assets.itemRefresher.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Refresher.png';
    assets.itemSlowmo.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Clock.png';
    assets.itemInvul.src = 'https://raw.githubusercontent.com/that-geographer/geo-escape/refs/heads/main/assets/Block.png';

    let gameActive = false;
    let currentLevel = 1;
    let progressThisLevel = 0;
    let totalPoints = 0;
    let currentPlayerName = "–ì–µ–æ–≥—Ä–∞—Ñ";
    let itemsDroppedThisLevel = 0;
    const TARGET_PER_LEVEL = 20;
    
    const config = {
        playerSpeed: 5.2,
        baseStudentSpeed: 2.1,
        baseSpawnRate: 1700,
        minSpawnRate: 400,
        abilityCooldown: 1000,
        projectileSpeed: 11,
        stunDuration: 500,
        bossHP: 10,
        bossShotCount: 8,
        bossShotInterval: 3000,
        itemDropChance: 0.15 
    };

    const player = {
        x: 0, y: 0, radius: 25,
        lastAbilityTime: 0, ultAvailable: true,
        stunUntil: 0, invulnerableUntil: 0, slowMoUntil: 0
    };

    let enemies = [];
    let projectiles = [];
    let enemyProjectiles = [];
    let obstacles = [];
    let items = [];
    let animationId;
    let lastSpawnTime = 0;
    let spawnTimer = config.baseSpawnRate;
    let specialEnemyActive = false;
    const keys = {};

    let highScores = JSON.parse(localStorage.getItem('geography_scores') || '[]');

    function saveScore(points, name) {
        const entry = { points, name, date: new Date().toLocaleDateString() };
        highScores.push(entry);
        highScores.sort((a, b) => b.points - a.points);
        highScores = highScores.slice(0, 10);
        localStorage.setItem('geography_scores', JSON.stringify(highScores));
    }

    function showResults() {
        const container = document.getElementById('results-container');
        container.innerHTML = '';
        if (highScores.length === 0) {
            container.innerHTML = '<p class="text-center text-gray-500 py-4">–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∫–æ—Ä–¥–æ–≤</p>';
        } else {
            highScores.forEach((s, i) => {
                container.innerHTML += `
                    <div class="result-item">
                        <div class="flex flex-col">
                            <span class="font-bold text-gray-800">${i + 1}. ${s.name || '–ê–Ω–æ–Ω–∏–º'}</span>
                            <span class="text-xs text-gray-400">${s.date}</span>
                        </div>
                        <span class="font-bold text-red-700">${s.points} –æ—á–∫–æ–≤</span>
                    </div>`;
            });
        }
    }

    function resize() {
        canvas.width = window.innerWidth > 800 ? 800 : window.innerWidth;
        canvas.height = window.innerHeight > 600 ? 600 : window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function isKeyDown(code, engChar, rusChar) {
        return keys[code] || keys[engChar] || keys[rusChar];
    }

    window.addEventListener('keydown', e => {
        keys[e.code] = true; 
        if (e.key) keys[e.key.toLowerCase()] = true;
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        
        if (gameActive) {
            if (e.code === 'Space' || e.key === ' ') fireGlobe();
            if (e.code === 'KeyE' || e.key?.toLowerCase() === 'e' || e.key?.toLowerCase() === '—É') useUltimate();
        }
    });

    window.addEventListener('keyup', e => {
        keys[e.code] = false; 
        if (e.key) keys[e.key.toLowerCase()] = false;
    });

    class Item {
        constructor(x, y) {
            this.x = x; this.y = y; this.radius = 20; this.active = true;
            this.birth = Date.now(); this.duration = 10000; 
            const rand = Math.random();
            if (rand < 0.33) { this.type = 'slowmo'; this.img = assets.itemSlowmo; this.name = '–ó–ê–ú–ï–î–õ–ï–ù–ò–ï'; }
            else if (rand < 0.66) { this.type = 'refresher'; this.img = assets.itemRefresher; this.name = '–†–ï–§–†–ï–®–ï–†'; }
            else { this.type = 'invul'; this.img = assets.itemInvul; this.name = '–ù–ï–£–Ø–ó–í–ò–ú–û–°–¢–¨'; }
        }
        update() {
            if (Date.now() - this.birth > this.duration) this.active = false;
            if (Math.hypot(player.x - this.x, player.y - this.y) < player.radius + this.radius) {
                this.apply(); this.active = false;
            }
        }
        apply() {
            const now = Date.now();
            if (this.type === 'slowmo') { player.slowMoUntil = now + 5000; announceEffect("–í–†–ï–ú–Ø –ó–ê–ú–ï–î–õ–ï–ù–û!"); }
            else if (this.type === 'refresher') { player.ultAvailable = true; announceEffect("–£–õ–¨–¢–ê –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ê!"); }
            else if (this.type === 'invul') { player.invulnerableUntil = now + 8000; announceEffect("–ù–ï–£–Ø–ó–í–ò–ú–û–°–¢–¨!"); }
        }
        draw() {
            ctx.save();
            const bounce = Math.sin(Date.now() / 200) * 5;
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(this.x, this.y + 22, 16, 7, 0, 0, Math.PI*2);
            ctx.fill();
            if (this.img.complete) {
                ctx.drawImage(this.img, this.x - this.radius, this.y - this.radius + bounce, this.radius * 2, this.radius * 2);
            }
            ctx.restore();
        }
    }

    function announceEffect(txt) {
        const div = document.createElement('div');
        div.className = 'effect-tag';
        div.innerText = txt;
        effectsContainer.appendChild(div);
        setTimeout(() => div.remove(), 2000);
    }

    class Obstacle {
        constructor() {
            let valid = false;
            while (!valid) {
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = Math.random() * (canvas.height - 100) + 50;
                this.radius = 26;
                this.type = Math.random() > 0.5 ? 'desk' : 'chair';
                const distToCenter = Math.hypot(this.x - canvas.width/2, this.y - canvas.height/2);
                if (distToCenter > 130) valid = true;
            }
        }
        draw() {
            const img = this.type === 'desk' ? assets.desk : assets.chair;
            if (img.complete && img.naturalWidth !== 0) {
                ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            }
        }
    }

    class Projectile {
        constructor(x, y, vx, vy, isEnemy = false) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.radius = isEnemy ? 10 : 18;
            this.active = true;
            this.isEnemy = isEnemy;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) this.active = false;
        }
        draw() {
            ctx.save();
            if (this.isEnemy) {
                ctx.fillStyle = "white"; ctx.strokeStyle = "#2c3e50"; ctx.lineWidth = 2;
                ctx.fillRect(this.x - 8, this.y - 10, 16, 20);
                ctx.strokeRect(this.x - 8, this.y - 10, 16, 20);
                ctx.fillStyle = "#2c3e50"; ctx.fillRect(this.x - 5, this.y - 5, 10, 2); ctx.fillRect(this.x - 5, this.y + 1, 10, 2);
            } else {
                if (assets.globe.complete) {
                    ctx.translate(this.x, this.y); ctx.rotate(Date.now() / 200);
                    ctx.drawImage(assets.globe, -this.radius, -this.radius, this.radius * 2, this.radius * 2);
                } else {
                    ctx.font = '28px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('üåç', this.x, this.y);
                }
            }
            ctx.restore();
        }
    }

    class Student {
        constructor(level, isSpecial = false, isBoss = false) {
            this.isBoss = isBoss;
            if (isBoss) {
                this.x = canvas.width / 2; this.y = -60; this.hp = config.bossHP; this.maxHp = config.bossHP;
                this.radius = 45; this.speed = 1.2; this.lastShotTime = Date.now();
            } else {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { this.x = -40; this.y = Math.random() * canvas.height; }
                else if (side === 1) { this.x = canvas.width + 40; this.y = Math.random() * canvas.height; }
                else if (side === 2) { this.x = Math.random() * canvas.width; this.y = -40; }
                else { this.x = Math.random() * canvas.width; this.y = canvas.height + 40; }
                this.radius = 24; this.hp = 1;
                const baseSpeed = config.baseStudentSpeed + (level * 0.12);
                this.speed = isSpecial ? baseSpeed * 0.7 : baseSpeed;
            }
            this.isSpecial = isSpecial || isBoss;
            this.active = true; this.knockedOut = false; this.vx = 0; this.vy = 0;
            this.lastShotTime = Date.now();
        }
        update() {
            if (this.knockedOut) {
                this.x += this.vx; this.y += this.vy;
                if (this.x < -150 || this.x > canvas.width + 150 || this.y < -150 || this.y > canvas.height + 150) {
                    this.active = false; if (this.isSpecial) specialEnemyActive = false;
                }
                return;
            }
            const isSlowed = Date.now() < player.slowMoUntil;
            const currentSpeed = isSlowed ? this.speed * 0.5 : this.speed;
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            if (this.isBoss) {
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist > 150) { this.x += Math.cos(angle) * currentSpeed; this.y += Math.sin(angle) * currentSpeed; }
                if (Date.now() - this.lastShotTime > config.bossShotInterval) {
                    // Boss Shoots
                    playSound('bossShot');
                    for (let i = 0; i < config.bossShotCount; i++) {
                        const sAngle = (Math.PI * 2 / config.bossShotCount) * i;
                        enemyProjectiles.push(new Projectile(this.x, this.y, Math.cos(sAngle)*5.5, Math.sin(sAngle)*5.5, true));
                    }
                    this.lastShotTime = Date.now();
                }
            } else {
                this.x += Math.cos(angle) * currentSpeed; this.y += Math.sin(angle) * currentSpeed;
                if (this.isSpecial && Date.now() - this.lastShotTime > 2500) {
                    // Special Student Shoots
                    playSound('specialShot');
                    const sAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    enemyProjectiles.push(new Projectile(this.x, this.y, Math.cos(sAngle)*6.5, Math.sin(sAngle)*6.5, true));
                    this.lastShotTime = Date.now();
                }
            }
        }
        draw() {
            ctx.save();
            if (this.knockedOut) ctx.globalAlpha = 0.5;
            const img = this.isSpecial ? assets.studentSpecial : assets.studentNormal;
            if (img.complete && img.naturalWidth !== 0) {
                ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            }
            if (this.isBoss && !this.knockedOut) {
                const barW = 80; const barH = 8;
                ctx.fillStyle = '#ddd'; ctx.fillRect(this.x - barW/2, this.y - this.radius - 15, barW, barH);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(this.x - barW/2, this.y - this.radius - 15, barW * (this.hp / this.maxHp), barH);
            }
            ctx.restore();
        }
    }

    function fireGlobe() {
        if (Date.now() < player.stunUntil) return;
        const now = Date.now();
        if (now - player.lastAbilityTime < config.abilityCooldown) return;
        let sx = 0, sy = 0;
        if (isKeyDown('KeyW', 'w', '—Ü')) sy -= 1;
        if (isKeyDown('KeyS', 's', '—ã')) sy += 1;
        if (isKeyDown('KeyA', 'a', '—Ñ')) sx -= 1;
        if (isKeyDown('KeyD', 'd', '–≤')) sx += 1;
        if (sx === 0 && sy === 0) return;
        player.lastAbilityTime = now;
        const len = Math.hypot(sx, sy);
        
        playSound('globeThrow');
        projectiles.push(new Projectile(player.x, player.y, (sx/len)*config.projectileSpeed, (sy/len)*config.projectileSpeed));
    }

    function useUltimate() {
        if (Date.now() < player.stunUntil || !player.ultAvailable) return;
        player.ultAvailable = false;
        
        playSound('globeThrow');
        [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},{x:1,y:1},{x:1,y:-1},{x:-1,y:1},{x:-1,y:-1}].forEach(d => {
            const len = Math.hypot(d.x, d.y);
            projectiles.push(new Projectile(player.x, player.y, (d.x/len)*config.projectileSpeed, (d.y/len)*config.projectileSpeed));
        });
    }

    function startNewLevel() {
        currentLevel++; progressThisLevel = 0; itemsDroppedThisLevel = 0;
        enemies = []; projectiles = []; enemyProjectiles = []; items = [];
        specialEnemyActive = false; player.ultAvailable = true; 
        spawnTimer = Math.max(config.minSpawnRate, config.baseSpawnRate - (currentLevel * 160));
        const isBossLevel = currentLevel % 5 === 0;
        levelAnnounce.innerText = isBossLevel ? "–ë–û–°–°: –õ–ò–î–ï–† –ö–õ–ê–°–°–ê" : "–ù–û–í–´–ô –ì–û–î –ë–õ–ò–ó–ö–û!";
        levelAnnounce.style.opacity = "1";
        setTimeout(() => levelAnnounce.style.opacity = "0", 1800);
        levelElement.innerText = currentLevel;
        if (isBossLevel) {
            levelTitle.innerText = "–£–†–û–í–ï–ù–¨ –ë–û–°–°–ê";
            scoreContainer.innerHTML = '–ó–¥–æ—Ä–æ–≤—å–µ –±–æ—Å—Å–∞: <span id="score">10</span> / 10';
        } else {
            levelTitle.innerText = "–£—Ä–æ–≤–µ–Ω—å: " + currentLevel;
            scoreContainer.innerHTML = '–¢–µ—Ç—Ä–∞–¥–∏: <span id="score">0</span> / 20';
        }
        obstacles = [];
        const count = 5 + Math.floor(currentLevel * 1.2);
        for(let i = 0; i < Math.min(count, 18); i++) obstacles.push(new Obstacle());
        if (isBossLevel) { enemies.push(new Student(currentLevel, false, true)); specialEnemyActive = true; }
    }

    function initGame() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        // Start BGM
        if (audioSettings.enabled) {
            bgmAudio.currentTime = 0;
            bgmAudio.volume = audioSettings.musicVolume;
            bgmAudio.play().catch(e => console.log('BGM Error', e));
        }

        cancelAnimationFrame(animationId);
        currentPlayerName = nicknameInput.value.trim() || "–ì–µ–æ–≥—Ä–∞—Ñ";
        document.getElementById('ui-nickname').innerText = currentPlayerName;
        currentLevel = 1; progressThisLevel = 0; totalPoints = 0; itemsDroppedThisLevel = 0;
        enemies = []; projectiles = []; enemyProjectiles = []; items = [];
        player.x = canvas.width/2; player.y = canvas.height/2;
        player.lastAbilityTime = 0; player.ultAvailable = true; player.stunUntil = 0;
        player.invulnerableUntil = 0; player.slowMoUntil = 0;
        spawnTimer = config.baseSpawnRate; specialEnemyActive = false;
        levelTitle.innerText = "–£—Ä–æ–≤–µ–Ω—å: 1";
        scoreContainer.innerHTML = '–¢–µ—Ç—Ä–∞–¥–∏: <span id="score">0</span> / 20';
        obstacles = [];
        for(let i = 0; i < 5; i++) obstacles.push(new Obstacle());
        gameActive = true;
        mainMenu.classList.add('hidden'); gameOverMenu.classList.add('hidden'); uiOverlay.classList.remove('hidden');
        pointsElement.innerText = 0; progressFill.style.width = '0%'; effectsContainer.innerHTML = '';
        gameLoop();
    }

    function endGame() {
        gameActive = false; 
        bgmAudio.pause();
        
        uiOverlay.classList.add('hidden');
        gameOverMenu.classList.remove('hidden');
        document.getElementById('final-points').innerText = totalPoints;
        document.getElementById('player-name-final').innerText = currentPlayerName;
        saveScore(totalPoints, currentPlayerName);
    }

    function update() {
        const now = Date.now();
        const isBossLevel = currentLevel % 5 === 0;
        if (now >= player.stunUntil) {
            let mx = 0, my = 0;
            if (isKeyDown('ArrowUp')) my -= 1; if (isKeyDown('ArrowDown')) my += 1;
            if (isKeyDown('ArrowLeft')) mx -= 1; if (isKeyDown('ArrowRight')) mx += 1;
            if (mx !== 0 || my !== 0) {
                const len = Math.hypot(mx, my);
                player.x += (mx/len)*config.playerSpeed; player.y += (my/len)*config.playerSpeed;
            }
        }
        player.x = Math.max(player.radius, Math.min(canvas.width-player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(canvas.height-player.radius, player.y));
        obstacles.forEach(o => {
            const d = Math.hypot(player.x-o.x, player.y-o.y);
            if (d < player.radius + o.radius - 5) {
                const a = Math.atan2(player.y-o.y, player.x-o.x);
                player.x = o.x + Math.cos(a)*(player.radius+o.radius - 5);
                player.y = o.y + Math.sin(a)*(player.radius+o.radius - 5);
            }
        });
        if (!isBossLevel && now - lastSpawnTime > spawnTimer) {
            const s = !specialEnemyActive && progressThisLevel >= 5 && Math.random() < 0.25;
            enemies.push(new Student(currentLevel, s)); if (s) specialEnemyActive = true;
            lastSpawnTime = now;
        }
        projectiles.forEach((p, pi) => {
            p.update(); if (!p.active) { projectiles.splice(pi, 1); return; }
            enemies.forEach(e => {
                if (!e.knockedOut && Math.hypot(p.x-e.x, p.y-e.y) < p.radius+e.radius) {
                    p.active = false; 
                    
                    playSound('globeHit');
                    playSound('studentHit');

                    if (e.isBoss) {
                        e.hp--; totalPoints += 20;
                        if (e.hp <= 0) { e.knockedOut = true; e.vx = p.vx*1.4; e.vy = p.vy*1.4; totalPoints += 600; setTimeout(startNewLevel, 1000); }
                    } else {
                        e.knockedOut = true; e.vx = p.vx*1.4; e.vy = p.vy*1.4;
                        totalPoints += e.isSpecial ? 30 : 15; progressThisLevel++;
                        if (itemsDroppedThisLevel < 3 && Math.random() < config.itemDropChance) { items.push(new Item(e.x, e.y)); itemsDroppedThisLevel++; }
                        if (progressThisLevel >= TARGET_PER_LEVEL) { totalPoints += 500; setTimeout(startNewLevel, 500); }
                    }
                    if (isBossLevel) {
                        const boss = enemies.find(en => en.isBoss);
                        const displayHp = boss ? Math.max(0, boss.hp) : 0;
                        document.getElementById('score').innerText = displayHp;
                        progressFill.style.width = (displayHp/config.bossHP*100)+'%';
                    } else {
                        document.getElementById('score').innerText = progressThisLevel;
                        progressFill.style.width = (progressThisLevel/TARGET_PER_LEVEL*100)+'%';
                    }
                    pointsElement.innerText = totalPoints;
                }
            });
        });
        enemyProjectiles.forEach((ep, epi) => {
            ep.update(); if (!ep.active) { enemyProjectiles.splice(epi, 1); return; }
            if (now > player.invulnerableUntil && Math.hypot(ep.x-player.x, ep.y-player.y) < ep.radius+player.radius) {
                player.stunUntil = now + config.stunDuration; ep.active = false;
            }
        });
        enemies.forEach((e, ei) => {
            e.update(); if (!e.active) { enemies.splice(ei, 1); return; }
            if (!e.knockedOut && now > player.invulnerableUntil && Math.hypot(player.x-e.x, player.y-e.y) < player.radius+e.radius-8) { endGame(); }
        });
        items.forEach((item, ii) => { item.update(); if (!item.active) items.splice(ii, 1); });
        const abilityStatus = document.getElementById('ability-status');
        const ultStatus = document.getElementById('ult-status');
        if (now - player.lastAbilityTime < config.abilityCooldown) {
            abilityStatus.innerText = '–ì–õ–û–ë–£–°: –ó–ê–†–Ø–î–ö–ê'; abilityStatus.className = 'font-bold text-gray-400';
        } else {
            abilityStatus.innerText = '–ì–õ–û–ë–£–°: –ì–û–¢–û–í'; abilityStatus.className = 'font-bold text-blue-600';
        }
        if (player.ultAvailable) {
            ultStatus.innerText = '–£–õ–¨–¢–ê [E]: –ì–û–¢–û–í–ê'; ultStatus.className = 'font-bold text-purple-600';
        } else {
            ultStatus.innerText = '–£–õ–¨–¢–ê: –ó–ê–†–Ø–î–ò–¢–°–Ø –í –°–õ–ï–î. –£–†–û–í–ù–ï'; ultStatus.className = 'font-bold text-gray-400 text-sm';
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#d5e6f5'; ctx.lineWidth = 1;
        for(let i=0;i<canvas.width;i+=50){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,canvas.height);ctx.stroke();}
        for(let i=0;i<canvas.height;i+=50){ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(canvas.width,i);ctx.stroke();}
        obstacles.forEach(o => o.draw());
        items.forEach(item => item.draw());
        projectiles.forEach(p => p.draw());
        enemyProjectiles.forEach(ep => ep.draw());
        ctx.save(); 
        const now = Date.now();
        if (now < player.stunUntil) ctx.globalAlpha = 0.5;
        if (now < player.invulnerableUntil) { ctx.shadowBlur = 15; ctx.shadowColor = "gold"; ctx.globalAlpha = 0.85; }
        if (assets.player.complete) {
            ctx.drawImage(assets.player, player.x-player.radius, player.y-player.radius, player.radius*2, player.radius*2);
        }
        ctx.restore();
        enemies.forEach(e => e.draw());
        if (now < player.slowMoUntil) {
            ctx.fillStyle = 'rgba(0, 100, 255, 0.08)';
            ctx.fillRect(0,0, canvas.width, canvas.height);
        }
    }

    function gameLoop() { 
        if (!gameActive) return; 
        update(); draw(); 
        animationId = requestAnimationFrame(gameLoop); 
    }

    // Buttons
    document.getElementById('start-btn').onclick = initGame;
    document.getElementById('retry-btn').onclick = initGame;
    document.getElementById('controls-btn').onclick = () => { mainMenu.classList.add('hidden'); controlsMenu.classList.remove('hidden'); };
    document.getElementById('results-btn').onclick = () => { mainMenu.classList.add('hidden'); resultsMenu.classList.remove('hidden'); showResults(); };
    document.getElementById('settings-btn').onclick = () => { mainMenu.classList.add('hidden'); settingsMenu.classList.remove('hidden'); if(audioCtx.state === 'suspended') audioCtx.resume(); };

    document.getElementById('back-to-main-from-ctrl').onclick = () => { controlsMenu.classList.add('hidden'); mainMenu.classList.remove('hidden'); };
    document.getElementById('back-to-main-from-res').onclick = () => { resultsMenu.classList.add('hidden'); mainMenu.classList.remove('hidden'); };
    document.getElementById('back-to-main-from-settings').onclick = () => { settingsMenu.classList.add('hidden'); mainMenu.classList.remove('hidden'); };
    document.getElementById('to-menu-btn').onclick = () => { gameOverMenu.classList.add('hidden'); mainMenu.classList.remove('hidden'); ctx.clearRect(0, 0, canvas.width, canvas.height); };

    function drawMenuBg() { if (gameActive) return; draw(); requestAnimationFrame(drawMenuBg); }
    drawMenuBg();
</script>
</body>
</html>
